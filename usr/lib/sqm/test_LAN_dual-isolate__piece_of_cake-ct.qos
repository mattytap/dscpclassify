#!/bin/sh
################################################################################
# test_LAN_triple-isolate__piece_of_cake.qos (Cero3 Shaper)
#
# Abstract:
# This is a one band cake and ipv6 enabled shaping script for Ethernet
# gateways. This exists for the purpose of testing cake's different isolation
# options, specifically the non-directional triple-isolate feature that promises
# to finally tackle the bit-torrent hole in simple.qos.
# This specific version is supposed to be used on LAN interfaces:
# 	the script's ingress direction equals the internet/WAN upload direction
# 	the script's egress direction equals the internet/WAN download direction
#
# NOTE: Shaping on a LAN interface only affects machines connected via that
#	LAN interface, so typically WIFI/WLAN traffic will not be shaped!
#
################################################################################
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
#  Copyright (C) 2012-2016
#    Michael D. Taht, Toke Høiland-Jørgensen, Sebastian Moeller
#
################################################################################


. ${SQM_LIB_DIR}/defaults.sh

################################################################################


# this will only work with cake as qdisc...
QDISC=cake


# to keep this as simple as possible we ignore the *_CAKE_OPTS from defaults.sh

INGRESS_CAKE_OPTS="besteffort dual-srchost"
EGRESS_CAKE_OPTS="besteffort dual-dsthost"

egress() {
    sqm_debug "egress"


    SILENT=1 $TC qdisc del dev $IFACE root
    $TC qdisc add dev $IFACE root $( get_stab_string ) cake \
        bandwidth ${UPLINK}kbit $( get_cake_lla_string ) ${EGRESS_CAKE_OPTS} ${EQDISC_OPTS}
}


ingress() {
    sqm_debug "ingress"

    SILENT=1 $TC qdisc del dev $IFACE handle ffff: ingress
    $TC qdisc add dev $IFACE handle ffff: ingress

    SILENT=1 $TC qdisc del dev $DEV root


    $TC qdisc add dev $DEV root $( get_stab_string ) cake \
        bandwidth ${DOWNLINK}kbit $( get_cake_lla_string ) ${INGRESS_CAKE_OPTS} ${IQDISC_OPTS}

    $IP link set dev $DEV up

    # redirect all IP packets arriving in $IFACE to ifb0
    # set DSCP mark from conntrack mark (pull from conntrack table in kernel: conntrack -L mark field)
    # based on https://www.man7.org/linux/man-pages/man8/tc-ctinfo.8.html
    # CTINFO (Conntrack Information) is a tc action for retrieving data
    # from conntrack marks into various fields.
    # DSCP mode (tc ctinfo dscp ) copies a DSCP stored in conntrack's connmark into the
    # IPv4/v6 diffserv field.  The copying may conditionally occur
    # based on a flag also stored in the connmark.  DSCP mode was
    # designed to assist in restoring packet classifications on
    # ingress, classifications which may then be used by qdiscs such as
    # CAKE.  It may be used in any circumstance where ingress
    # classification needs to be maintained across links that otherwise
    # bleach or remap according to their own policies.

    # the ctinfo in set in nftables on first (and subsequebt frames in connection)
    # ct mark set meta mark

    # but as per commit cbfd72d
    # Use 'matchall' filter type to match all packets instead of u32 matching on everything.

    # Remove flowid 1:1 as this can make cake 'flow blind' see:
    # https://lists.bufferbloat.net/pipermail/cake/2019-September/005031.html
    $TC filter add dev $IFACE parent ffff: matchall \
    action ctinfo dscp 0x0000003f mirred egress redirect dev $DEV
}

sqm_start() {

    #sm: flip upload and download bandwith so that the GUI values reflect directionality in regard to the ISP
    #sm: NOTE this is ugly and should be performed in defaults.sh or functions.sh if at all
    #sm: but for quick and dirty testing this should do
    local ORIG_UPLINK=${UPLINK}
    local ORIG_DOWNLINK=${DOWNLINK}
    UPLINK=${ORIG_DOWNLINK}
    DOWNLINK=${ORIG_UPLINK}


    [ -n "$IFACE" ] || return 1


    do_modules
    verify_qdisc $QDISC "cake" || return 1
    sqm_debug "sqm_start: Starting ${SCRIPT}"

    [ -z "$DEV" ] && DEV=$( get_ifb_for_if ${IFACE} )


    if [ "${UPLINK}" -ne 0 ];
    then
	    fn_exists egress && egress || sqm_warn "sqm_start_default: ${SCRIPT} lacks an egress() function"
        #egress
        sqm_debug "sqm_start: egress shaping activated"
    else
        sqm_debug "sqm_start: egress shaping deactivated"
        SILENT=1 $TC qdisc del dev ${IFACE} root
    fi


    if [ "${DOWNLINK}" -ne 0 ];
    then
    	verify_qdisc ingress "ingress" || return 1
    	fn_exists ingress && ingress || sqm_warn "sqm_start_default: ${SCRIPT} lacks an ingress() function"
        #ingress
        sqm_debug "sqm_start: ingress shaping activated"
    else
        sqm_debug "sqm_start: ingress shaping deactivated"
        SILENT=1 $TC qdisc del dev ${DEV} root
        SILENT=1 $TC qdisc del dev ${IFACE} ingress
    fi
    return 0
}
